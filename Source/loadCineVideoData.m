function vid = loadCineVideoData(fileName)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% loadCineVideoData: A function for loading the video data from cine video
%   files generated by Vision Research Phantom cameras. This is based on
%   the "ReadCineFileImage" function provided with the Phantom SDK
% usage:  
%   LoadPhantomLibraries();
%   RegisterPhantom(true); %Register the Phantom dll's ignoring connected cameras. 
%						 %Use this function once at the begining of your work
%   videoData = loadCineVideoData(fileName)
%   UnregisterPhantom(); %Use this function when you finished your work
%   UnloadPhantomLibraries();
%
% where,
%    fileName is the path to a cine file
%
% This function reads video data from a cine file into an 3 or 4D array.
%
% See also: <related functions>

% Version: 0.1
% Author:  Brian Kardon
% Email:   bmk27=cornell*org, brian*kardon=google*com
% Real_email = regexprep(Email,{'=','*'},{'@','.'})
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Create the cine handle from the cine file.
%Is recomended that cine handle creation should be done once for a batch of image readings. 
%This will increase speed.
[HRES, cineHandle] = PhNewCineFromFile(fileName);
if (HRES<0)
	[message] = PhGetErrorMessage( HRES );
    error(['Cine handle creation error: ' message]);
end

%% Get information about cine
%read the saved range
pFirstIm = libpointer('int32Ptr',0);
PhGetCineInfo(cineHandle, PhFileConst.GCI_FIRSTIMAGENO, pFirstIm);
firstIm = pFirstIm.Value;
pImCount = libpointer('uint32Ptr',0);
PhGetCineInfo(cineHandle, PhFileConst.GCI_IMAGECOUNT, pImCount);
lastIm = int32(double(firstIm) + double(pImCount.Value) - 1);
%get cine image buffer size
pInfVal = libpointer('uint32Ptr',0);
PhGetCineInfo(cineHandle, PhFileConst.GCI_MAXIMGSIZE, pInfVal);
imgSizeInBytes = pInfVal.Value;
%The image flip for GetCineImage function is inhibited.
pInfVal = libpointer('int32Ptr',false);
PhSetCineInfo(cineHandle, PhFileConst.GCI_VFLIPVIEWACTIVE, pInfVal);
%Create the image range to be readed
imgRange = get(libstruct('tagIMRANGE'));
%take one image at imageNo
imgRange.First = 0;
imgRange.Cnt = double(lastIm);

%% Read the cine image into the buffer 
%The image will have image processings applied 
[HRES, unshiftedVid, imgHeader] = PhGetCineImage(cineHandle, imgRange, imgSizeInBytes*imgRange.Cnt);

%% Read image information from header
isColorImage = IsColorHeader(imgHeader);
is16bppImage = Is16BitHeader(imgHeader);

%% Transform 1D image pixels to 1D/3D image pixels to be used with MATLAB
if (HRES >= 0)
    bps = GetEffectiveBitsFromIH(imgHeader);
    [vid] = ExtractVideoMatrixFromVideoBuffer(unshiftedVid, imgHeader, imgRange.Cnt, bps);
    if (isColorImage)
        samplespp = 3;
    else
        samplespp = 1;
    end
%    [matlabIm, vid] = ConstructMatlabVideo(unshiftedVid, imgHeader.biWidth, imgHeader.biHeight, samplespp, bps, imgRange.Cnt);
end

% showImage = false;
% %% Show image
% if (showImage)
%     frameToShow=1;
%     if (isColorImage)
%         figure, image(squeeze(matlabIm(frameToShow,:,:,:)),'CDataMapping','scaled'),colormap('default');
%     else
%         figure, image(squeeze(matlabIm(frameToShow,:,:,:)),'CDataMapping','scaled'),colormap(gray(2^8));
%     end
% end
